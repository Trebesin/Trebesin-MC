{"version":3,"sources":["mc_modules/dimensions.js"],"names":[],"mappings":"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","file":"dimensions.js","sourcesContent":["/*\r\n    \"dimension.js\" - Helper functions to work within MC dimension.\r\n    Copyright (C) 2023  PavelDobCZ23\r\n\r\n    This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n    You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n*/\r\n\r\nimport * as Mc from \"@minecraft/server\";\r\nimport * as ArrayOps from '../js_modules/array';\r\nimport * as VectorMath from '../js_modules/vectorMath';\r\n\r\n\r\n/**\r\n * @typedef Position Defines an exact position in a Minecraft world.\r\n * @prop {Mc.Dimension} dimension Dimension where coordinate location is contained.\r\n * @prop {VectorMath.Vector3} location The coordinate location.\r\n */\r\n\r\n/**\r\n * @param {Mc.Entity | Mc.Block} object Entity or a block to get the position of.\r\n * @returns {Position}\r\n */\r\nexport function getPosition(object) {\r\n    return {\r\n        location: object.location,\r\n        dimension: object.dimension\r\n    };\r\n}\r\n\r\n/**\r\n * Function for comparing 2 positions.\r\n * @param {Position} positionA 1st position to compare.\r\n * @param {Position} positionB 2nd position to compare.\r\n * @returns {boolean} Boolean that is equal to `true` if the positions are at the exact same place, otherwise `false`.\r\n */\r\nexport function comparePositions(positionA,positionB) {\r\n    return (\r\n        positionA.dimension.id === positionB.dimension.id &&\r\n        positionA.location.x === positionB.location.x &&\r\n        positionA.location.y === positionB.location.y &&\r\n        positionA.location.z === positionB.location.z\r\n    );\r\n}\r\n\r\n//!remove all usage of arrays to store locations/vectors\r\n\r\nexport function getTopBlock(x, z, dimension, solid = false) {\r\n    return dimension.getBlockFromRay(\r\n        {x,y:320,z},\r\n        {x:0,y:-1,z:0},\r\n        {includeLiquidBlocks: !solid, includePassableBlocks: !solid, maxDistance: 400}\r\n    );\r\n}\r\n\r\nexport function getClosestBlock(coordinate, dimension = Mc.world.getDimension('overworld'), typeId = 'minecraft:air', options = {}) {\r\n    const OPTIONS = Object.assign({vectorMap:[{x:0,y:1,z:0},{x:0,y:-1,z:0}],maxDistance:256},options)\r\n    let emptyBlock = null;\r\n    const checkedBlocks = new Set();\r\n    let coords = [coordinate];\r\n    while (coords.length) {\r\n        const newCoords = [];\r\n        for (let index = 0;index < coords.length;index++) {\r\n            const coord = coords[index];\r\n            if (coord.some((element, index) => Math.abs(coordinate[index] - element) > maxDistance)) continue;\r\n            if (dimension.getBlock(coord).typeId === typeId) {\r\n                emptyBlock = coord;\r\n                coords.length = 0;\r\n                break;\r\n            } else {\r\n                checkedBlocks.add(locationToString(coord));\r\n                for (let vectorIndex = 0;vectorIndex < OPTIONS.vectorMap.length;vectorIndex++) {\r\n                    const vector = OPTIONS.vectorMap[vectorIndex];\r\n                    const newCoord = VectorMath.sum(vector,coord);\r\n                    if (!checkedBlocks.has(locationToString(newCoord))) {\r\n                        newCoords.push(newCoord);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        coords = newCoords;\r\n    }\r\n    return emptyBlock;\r\n}\r\n\r\n/**\r\n   * @arg {number[]} coordinate - Array of 3 integers reprsenting base coordinate, which the function spreads from.\r\n   * @arg {Object} options - Information defining behavior of the spread function.\r\n   * @arg {Number} options.chance - Decimal between 0 and 1 inclusive, it defines how likely is spread to occur for each iteration.\r\n   * @arg {Number} options.amount - Integer between 0 and Infinity, it defines how many times spread iteration occurs.\r\n   * @arg {Number} options.max - Integer between 0 and 256 inclusive, it defines the maximal amount of spread recursion that can happen.\r\n   * @arg {Object} vectorMap - The vector(direction) for each coordinate in which the spread occurs.\r\n   * @arg {number[]} vectorMap.x - Array of two Integers, it defines the range of random coordinate shift to occur for spread on X axis.\r\n   * @arg {number[]} vectorMap.y - Array of two Integers, it defines the range of random coordinate shift to occur for spread on Y axis.\r\n   * @arg {number[]} vectorMap.z - Array of two Integers, it defines the range of random coordinate shift to occur for spread on Z axis.\r\n**/\r\nexport function createRandomSpread(coordinate, options, vectorMap = { x: [-1, 1], y: [-1, 1], z: [-1, 1] }, callback) {\r\n    const blocks = new Set();\r\n    let coords = [coordinate];\r\n    let currentSpread = 0;\r\n    let spread = Object.assign({\r\n        chanceFunc: value => value / 2,\r\n        amountFunc: value => value / 2\r\n    }, options);\r\n\r\n    while (coords.length) {\r\n        currentSpread++;\r\n        if (currentSpread > spread.max) return\r\n        const newCoords = [];\r\n\r\n        for (const coord of coords) {\r\n            for (let index = spread.amount; index > 0; index--) {\r\n                if (Math.random() <= spread.chance) {\r\n                    const newCoord = {\r\n                        x: coord.x + randInt(vectorMap.x[0], vectorMap.x[1]),\r\n                        y: coord.y + randInt(vectorMap.y[0], vectorMap.y[1]),\r\n                        z: coord.z + randInt(vectorMap.z[0], vectorMap.z[1])\r\n                    };\r\n                    const newCoordString = locationToString(newCoord);\r\n                    if (blocks.has(newCoordString)) {\r\n                        blocks.add(newCoordString);\r\n                        newCoords.push(newCoord);\r\n                        callback(newCoord);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        coords = newCoords;\r\n        Object.assign(spread, {\r\n            chance: spread.chanceFunc(spread.chance),\r\n            amount: spread.amountFunc(spread.amount)\r\n        });\r\n    }\r\n}\r\n\r\n//!Instead one callback with argument \r\n/**\r\n   * Gets all blocks that can be filled starting from a single location and returns them and the edges, alternatively callbacks can also be used.\r\n   * @arg {object} origin - Base coordinates, which the function fills its surounding area from.\r\n   * @arg {number} origin.x - Integer of the base X coordinate.\r\n   * @arg {number} origin.y - Integer of the base Y coordinate.\r\n   * @arg {number} origin.z - Integer of the base Z coordinate.\r\n   * @arg {Dimension} dimension - The dimension which the function anlyzes for the fill.\r\n   * @arg {string[]} options.whitelist - Block IDs of the blocks that can be filled.\r\n   * @arg {number} options.maxDistance - Integer between 0 and Infinity, it defines the maximal distance each coordinate can take.\r\n   * @arg {number[][]} options.vectorMap - Array of vector coordinates defined as Arrays of 3 Numbers that the function attempts to fill.\r\n   * @returns {undefined}\r\n**/\r\nexport function getAreaFill(origin, dimension, options, innerCallback, outerCallback) {\r\n    const fill = Object.assign({\r\n        whitelist: ['minecraft:air'],\r\n        maxDistance: 256,\r\n        vectorMap: [[1,0,0],[-1,0,0],[0,1,0],[0,-1,0],[0,0,1],[0,0,-1]]\r\n    },options);\r\n    \r\n    const coords = [origin];\r\n    const checkedBlocks = new Set();\r\n    while (coords.length) {\r\n        const coord = coords.shift();\r\n        if (outsideDistance(coord,origin,fill.maxDistance)) continue;\r\n        const currentBlock = dimension.getBlock(coord);\r\n        if (ArrayOps.includes(fill.whitelist,currentBlock.typeId)) {\r\n            innerCallback(coord);\r\n            for (const vector of fill.vectorMap) {\r\n                const newCoord = VectorMath.sum(coord,vector);\r\n                const newCoordString = locationToString(newCoord)\r\n                if (!checkedBlocks.has(newCoordString)) {\r\n                    coords.push(newCoord);\r\n                }\r\n            }\r\n        } else {\r\n            outerCallback(coord);\r\n        }\r\n        checkedBlocks.add(locationToString(coord));\r\n    }\r\n}\r\n\r\nfunction containsArray(array,item) {\r\n    const indexes = item.length;\r\n    let found = false;\r\n    arrayLoop: \r\n    for (const element of array) {\r\n        for (let index = 0; index < indexes; index++) {\r\n            if (!(element[index] === item[index])) {\r\n                continue arrayLoop\r\n            }\r\n        }\r\n        found = true;\r\n        break arrayLoop \r\n    }\r\n    return found\r\n}\r\n\r\nfunction randInt(min, max) {\r\n    max++;\r\n    return Math.floor(Math.random() * (max - min) + min);\r\n}\r\n\r\nfunction locationToString(location) {\r\n    return `${location.x},${location.y},${location.z}`;\r\n}\r\n\r\nfunction outsideDistance(locationA,locationB,distance) {\r\n    return (\r\n        Math.abs(locationA.x - locationB.x) > distance ||\r\n        Math.abs(locationA.y - locationB.y) > distance ||\r\n        Math.abs(locationA.z - locationB.z) > distance\r\n    )\r\n}\r\n\r\nfunction outsideDistanceSquered(locationA,locationB,distance) {\r\n    return (\r\n        (locationA.x-locationB.x)**2+\r\n        (locationA.y-locationB.y)**2+\r\n        (locationA.z-locationB.z)**2\r\n    ) > distance**2;\r\n}\r\n\r\n//!new filler algorithm - start with 6 main vectors with set children vectors which are vectors\r\n//!that are sent by the main vector to start checking too"],"sourceRoot":"../../scripts/"}
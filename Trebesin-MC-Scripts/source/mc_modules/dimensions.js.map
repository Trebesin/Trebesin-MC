{"version":3,"sources":["mc_modules/dimensions.js"],"names":[],"mappings":"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","file":"dimensions.js","sourcesContent":["/*\n    \"dimension.js\" - Helper functions to work within MC dimension.\n    Copyright (C) 2023  PavelDobCZ23\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\nimport * as Mc from \"@minecraft/server\";\nimport * as ArrayOps from '../js_modules/array';\nimport * as VectorMath from '../js_modules/vectorMath';\n\n\n/**\n * @typedef Position Defines an exact position in a Minecraft world.\n * @prop {Mc.Dimension} dimension Dimension where coordinate location is contained.\n * @prop {VectorMath.Vector3} location The coordinate location.\n */\n\n/**\n * @param {Mc.Entity | Mc.Block} object Entity or a block to get the position of.\n * @returns {Position}\n */\nexport function getPosition(object) {\n    return {\n        location: object.location,\n        dimension: object.dimension\n    };\n}\n\n/**\n * Function for comparing 2 positions.\n * @param {Position} positionA 1st position to compare.\n * @param {Position} positionB 2nd position to compare.\n * @returns {boolean} Boolean that is equal to `true` if the positions are at the exact same place, otherwise `false`.\n */\nexport function comparePositions(positionA,positionB) {\n    return (\n        positionA.dimension.id === positionB.dimension.id &&\n        positionA.location.x === positionB.location.x &&\n        positionA.location.y === positionB.location.y &&\n        positionA.location.z === positionB.location.z\n    );\n}\n\n//!remove all usage of arrays to store locations/vectors\n\nexport function getTopBlock(x, z, dimension, solid = false) {\n    return dimension.getBlockFromRay(\n        {x,y:320,z},\n        {x:0,y:-1,z:0},\n        {includeLiquidBlocks: !solid, includePassableBlocks: !solid, maxDistance: 400}\n    );\n}\n\nexport function getClosestBlock(coordinate, dimension = Mc.world.getDimension('overworld'), typeId = 'minecraft:air', options = {}) {\n    const OPTIONS = Object.assign({vectorMap:[{x:0,y:1,z:0},{x:0,y:-1,z:0}],maxDistance:256},options)\n    let emptyBlock = null;\n    const checkedBlocks = new Set();\n    let coords = [coordinate];\n    while (coords.length) {\n        const newCoords = [];\n        for (let index = 0;index < coords.length;index++) {\n            const coord = coords[index];\n            if (coord.some((element, index) => Math.abs(coordinate[index] - element) > maxDistance)) continue;\n            if (dimension.getBlock(coord).typeId === typeId) {\n                emptyBlock = coord;\n                coords.length = 0;\n                break;\n            } else {\n                checkedBlocks.add(locationToString(coord));\n                for (let vectorIndex = 0;vectorIndex < OPTIONS.vectorMap.length;vectorIndex++) {\n                    const vector = OPTIONS.vectorMap[vectorIndex];\n                    const newCoord = VectorMath.sum(vector,coord);\n                    if (!checkedBlocks.has(locationToString(newCoord))) {\n                        newCoords.push(newCoord);\n                    }\n                }\n            }\n        }\n        coords = newCoords;\n    }\n    return emptyBlock;\n}\n\n/**\n   * @arg {number[]} coordinate - Array of 3 integers reprsenting base coordinate, which the function spreads from.\n   * @arg {Object} options - Information defining behavior of the spread function.\n   * @arg {Number} options.chance - Decimal between 0 and 1 inclusive, it defines how likely is spread to occur for each iteration.\n   * @arg {Number} options.amount - Integer between 0 and Infinity, it defines how many times spread iteration occurs.\n   * @arg {Number} options.max - Integer between 0 and 256 inclusive, it defines the maximal amount of spread recursion that can happen.\n   * @arg {Object} vectorMap - The vector(direction) for each coordinate in which the spread occurs.\n   * @arg {number[]} vectorMap.x - Array of two Integers, it defines the range of random coordinate shift to occur for spread on X axis.\n   * @arg {number[]} vectorMap.y - Array of two Integers, it defines the range of random coordinate shift to occur for spread on Y axis.\n   * @arg {number[]} vectorMap.z - Array of two Integers, it defines the range of random coordinate shift to occur for spread on Z axis.\n**/\nexport function createRandomSpread(coordinate, options, vectorMap = { x: [-1, 1], y: [-1, 1], z: [-1, 1] }, callback) {\n    const blocks = new Set();\n    let coords = [coordinate];\n    let currentSpread = 0;\n    let spread = Object.assign({\n        chanceFunc: value => value / 2,\n        amountFunc: value => value / 2\n    }, options);\n\n    while (coords.length) {\n        currentSpread++;\n        if (currentSpread > spread.max) return\n        const newCoords = [];\n\n        for (const coord of coords) {\n            for (let index = spread.amount; index > 0; index--) {\n                if (Math.random() <= spread.chance) {\n                    const newCoord = {\n                        x: coord.x + randInt(vectorMap.x[0], vectorMap.x[1]),\n                        y: coord.y + randInt(vectorMap.y[0], vectorMap.y[1]),\n                        z: coord.z + randInt(vectorMap.z[0], vectorMap.z[1])\n                    };\n                    const newCoordString = locationToString(newCoord);\n                    if (blocks.has(newCoordString)) {\n                        blocks.add(newCoordString);\n                        newCoords.push(newCoord);\n                        callback(newCoord);\n                    }\n                }\n            }\n        }\n        coords = newCoords;\n        Object.assign(spread, {\n            chance: spread.chanceFunc(spread.chance),\n            amount: spread.amountFunc(spread.amount)\n        });\n    }\n}\n\n//!Instead one callback with argument \n/**\n   * Gets all blocks that can be filled starting from a single location and returns them and the edges, alternatively callbacks can also be used.\n   * @arg {object} origin - Base coordinates, which the function fills its surounding area from.\n   * @arg {number} origin.x - Integer of the base X coordinate.\n   * @arg {number} origin.y - Integer of the base Y coordinate.\n   * @arg {number} origin.z - Integer of the base Z coordinate.\n   * @arg {Dimension} dimension - The dimension which the function anlyzes for the fill.\n   * @arg {string[]} options.whitelist - Block IDs of the blocks that can be filled.\n   * @arg {number} options.maxDistance - Integer between 0 and Infinity, it defines the maximal distance each coordinate can take.\n   * @arg {number[][]} options.vectorMap - Array of vector coordinates defined as Arrays of 3 Numbers that the function attempts to fill.\n   * @returns {undefined}\n**/\nexport function getAreaFill(origin, dimension, options, innerCallback, outerCallback) {\n    const fill = Object.assign({\n        whitelist: ['minecraft:air'],\n        maxDistance: 256,\n        vectorMap: [[1,0,0],[-1,0,0],[0,1,0],[0,-1,0],[0,0,1],[0,0,-1]]\n    },options);\n    \n    const coords = [origin];\n    const checkedBlocks = new Set();\n    while (coords.length) {\n        const coord = coords.shift();\n        if (outsideDistance(coord,origin,fill.maxDistance)) continue;\n        const currentBlock = dimension.getBlock(coord);\n        if (ArrayOps.includes(fill.whitelist,currentBlock.typeId)) {\n            innerCallback(coord);\n            for (const vector of fill.vectorMap) {\n                const newCoord = VectorMath.sum(coord,vector);\n                const newCoordString = locationToString(newCoord)\n                if (!checkedBlocks.has(newCoordString)) {\n                    coords.push(newCoord);\n                }\n            }\n        } else {\n            outerCallback(coord);\n        }\n        checkedBlocks.add(locationToString(coord));\n    }\n}\n\nfunction containsArray(array,item) {\n    const indexes = item.length;\n    let found = false;\n    arrayLoop: \n    for (const element of array) {\n        for (let index = 0; index < indexes; index++) {\n            if (!(element[index] === item[index])) {\n                continue arrayLoop\n            }\n        }\n        found = true;\n        break arrayLoop \n    }\n    return found\n}\n\nfunction randInt(min, max) {\n    max++;\n    return Math.floor(Math.random() * (max - min) + min);\n}\n\nfunction locationToString(location) {\n    return `${location.x},${location.y},${location.z}`;\n}\n\nfunction outsideDistance(locationA,locationB,distance) {\n    return (\n        Math.abs(locationA.x - locationB.x) > distance ||\n        Math.abs(locationA.y - locationB.y) > distance ||\n        Math.abs(locationA.z - locationB.z) > distance\n    )\n}\n\nfunction outsideDistanceSquered(locationA,locationB,distance) {\n    return (\n        (locationA.x-locationB.x)**2+\n        (locationA.y-locationB.y)**2+\n        (locationA.z-locationB.z)**2\n    ) > distance**2;\n}\n\n//!new filler algorithm - start with 6 main vectors with set children vectors which are vectors\n//!that are sent by the main vector to start checking too"]}
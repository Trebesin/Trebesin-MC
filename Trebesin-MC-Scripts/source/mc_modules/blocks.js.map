{"version":3,"sources":["mc_modules/blocks.js"],"names":[],"mappings":"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","file":"blocks.js","sourcesContent":["/*\n    \"blocks.js\" - Helper functions to work with MC blocks.\n    Copyright (C) 2023  PavelDobCZ23\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n*/\nimport * as Mc from '@minecraft/server'\nimport * as VectorMath from './../js_modules/vectorMath';\nimport { logMessage, sendLogMessage } from '../plugins/debug/debug';\nimport { DIRECTIONS, BLOCK_STATE_COMPONENTS } from './constants';\n\n/**\n * Function for comparing 2 `Block` class objects.\n * @param {Mc.Block} blockA 1st block to compare the other with.\n * @param {Mc.Block} blockB The other block to compare the 1st with.\n * @param {boolean} checkLocation If the location of the block should be checked as well.\n * @returns {boolean} Boolean that is equal to `true` if the blocks are identical, otherwise `false`.\n */\nexport function compareBlocks(blockA,blockB,checkLocation = false) {\n    if (\n        blockA == null || blockB == null ||\n        blockA.typeId !== blockB.typeId || \n        blockA.isWaterlogged !== blockB.isWaterlogged\n    ) return false;\n    \n    if (checkLocation) {\n        if (!(\n            blockA.dimension.id === blockB.dimension.id &&\n            blockA.location.x === blockB.location.x &&\n            blockA.location.y === blockB.location.y &&\n            blockA.location.z === blockB.location.z\n        )) return false;\n    }\n\n    return (blockA.permutation === blockB.permutation);\n}\n\n/**\n * Function to copy `Block` class objects with data that define its state regardless of its location.\n * @param {Mc.Block} block Block to copy.\n * @param {boolean} [includePosition] If `true` the block state information will contain `location` and `dimension` properties.\n * @returns {BlockState} Object containing copies of selected properties of the block.\n */\nexport function copyBlockState(block,includePosition = false) {\n    if (block == null) return null;\n    const blockState = {\n        typeId: block.typeId,\n        isWaterlogged: block.isWaterlogged,\n        permutation: block.permutation?.clone(),\n        components: copyBlockComponents(block)\n    }\n    if (includePosition) {\n        blockState.dimension = block.dimension;\n        blockState.location = block.location;\n    }\n    return blockState;\n}\n\n/**\n * Function to apply block state data to an existing block.\n * @param {Mc.Block} block Block to apply the state onto.\n * @param {BlockState} blockState Block state data to apply.\n */\nexport function applyBlockState(block,blockState) {\n    if (blockState.typeId) block.setType(Mc.MinecraftBlockTypes.get(blockState.typeId));\n    if (blockState.isWaterlogged) block.isWaterlogged = blockState.isWaterlogged;\n    if (blockState.permutation) block.setPermutation(blockState.permutation);\n    if (blockState.components) applyBlockComponents(block,blockState.components);\n}\n\n/**\n * Function to compare if 2 block states are matching.\n * @param {BlockState} blockStateA 1st block state data to compare.\n * @param {BlockState} blockStateB 2nd block state data to compare.\n * @param {boolean} ignoreComponents If `true` components will automatically pass the check.\n * @returns {boolean}\n */\nexport function compareBlockStates(blockStateA,blockStateB,ignoreComponents = false) {\n    return (\n        blockStateA != null && blockStateB != null &&\n        blockStateA.typeId === blockStateB.typeId &&\n        blockStateA.isWaterlogged === blockStateB.isWaterlogged &&\n        blockStateA.permutation === blockStateB.permutation &&\n        (ignoreComponents || compareBlockComponents(blockStateA.components,blockStateB.components))\n    );\n}\n\n/**\n * Function to compare if 2 block component states are matching.\n * @param {BlockComponentState} componentsA First block component state data to compare.\n * @param {BlockComponentState} componentsB Second block component state data to compare.\n * @returns {boolean | undefined} Returns the result of the comparison or `undefined` if any of the components are invalid.\n */\nexport function compareBlockComponents(componentsA,componentsB) {\n    if (componentsA == null || componentsB == null) return undefined;\n\n    for (const componentId in BLOCK_STATE_COMPONENTS) {\n        const componentDataA = componentsA[componentId];\n        const componentDataB = componentsB[componentId];\n        if (componentDataA != null && componentDataB != null) {\n            switch (componentId) {\n                case 'inventory': {\n                    return false;\n                }   break;\n                case 'sign': {\n                    const signCheck = (\n                        componentDataA.text === componentDataB.text && \n                        componentDataA.dyeColor === componentDataB.dyeColor && \n                        (componentDataA.rawText == null && componentDataB.rawText == null)\n                    );\n                    if (!signCheck) return false;\n                }   break;\n            }\n        } else if (\n            (componentDataA != null && componentDataB == null) || \n            (componentDataA == null && componentDataB != null)\n        ) return false;\n    }\n    return true;\n}\n\n/**\n * @typedef BlockState\n * @prop {string} typeId ID of the type of the block.\n * @prop {boolean} isWaterlogged Waterlog state of the block.\n * @prop {Mc.BlockPermutation} permutation Block permutation.\n * @prop {BlockComponentState} components State of the block components.\n * @prop {Mc.Dimension} [dimension] Dimension of a block. *Only included if position is explicitly requested.*\n * @prop {VectorMath.Vector3} [location] Coordinates of a block. *Only included if position is explicitly requested.*\n */\n\n/**\n * @typedef BlockSignComponentState Contains data of block sign component saved in a simple object.\n * @prop {string} text The sign text.\n * @prop {Mc.RawText} rawText The sign text if defined as a `RawMessage`.\n * @prop {Mc.DyeColor} dyeColor Dye color of the sign text.\n */\n\n/**\n * @typedef BlockComponentState Contains data of block components saved in a simple object.\n * @prop {Mc.ItemStack[]} inventory Array of `ItemStack` or `null`/`undefined` values which's index coresponds to the slot they are contained in inside the container.\n * @prop {BlockSignComponentState} sign Sign component data.\n */\n\n/**\n * Function to copy all components of a block.\n * @param {Mc.Block} block Block to copy.\n * @returns {BlockComponentState | undefined} Object containing copies of components of the block. `undefined` if the block is invalid.\n */\nexport function copyBlockComponents(block) {\n    if (block == null) return undefined;\n    const blockComponents = {};\n\n    /** @type {Mc.BlockInventoryComponent} */\n    const inventory = block.getComponent('inventory');\n    if (inventory != null && inventory?.container != null) {\n        blockComponents.inventory = [];\n        const {container} = inventory;\n        for (let slotIndex = 0;slotIndex < container.size;slotIndex++) {\n            try {\n                blockComponents.inventory[slotIndex] = container.getSlot(slotIndex).clone();\n            } catch {\n                blockComponents.inventory[slotIndex] = null;\n            }\n        }\n    }\n\n    /** @type {Mc.BlockSignComponent} */\n    const sign = block.getComponent('sign');\n    if (sign != null) {\n        blockComponents.sign = {\n            text: sign.getText(),\n            rawText: sign.getRawText(),\n            dyeColor: sign.getTextDyeColor()\n        }\n    }\n\n    return blockComponents;\n\n    //!These components do not have getter functions:\n    //const lavaContainer = block.getComponent('lavaContainer');\n    //const potionContainer = block.getComponent('potionContainer');\n    //const snowContainer = block.getComponent('snowContainer');\n    //const waterContainer = block.getComponent('waterContainer');\n    //const piston = block.getComponent('piston');\n    //const recordPlayer = block.getComponent('recordPlayer');\n}\n\n/**\n * Function to apply components from a co.\n * @param {Mc.Block} block Affected block.\n * @param {BlockComponentState} blockComponents Block components to apply.\n */\nexport function applyBlockComponents(block,blockComponents) {\n    for (let componentId in blockComponents) {\n        const componentData = blockComponents[componentId];\n        const component = block.getComponent(componentId);\n        if (component == null) continue;\n        switch (componentId) {\n            case 'inventory': {\n                const container = component.container;\n                for (let slotIndex = 0;slotIndex < componentData.length;slotIndex++) {\n                    container.setItem(slotIndex,componentData[slotIndex]);\n                }\n            }   break;\n            case 'sign': {\n                component.setText(componentData.text ?? componentData.rawText);\n                component.setTextDyeColor(componentData.dyeColor);\n            }   break;\n        }\n    }\n}\n\n\n//# Block Update Functions:\nexport function getAdjecentBlockCopies(coord,dimension) {\n    const blockArray = [];\n    for (let index = 0;index < DIRECTIONS.length;index++) {\n        const face = DIRECTIONS[index];\n        blockArray.push(copyBlockState(dimension.getBlock(VectorMath.sum(coord,face)),true));\n    }\n    return blockArray;\n}\n\nexport function getAdjecentBlocks(coord,dimension) {\n    const blockArray = [];\n    for (let index = 0;index < DIRECTIONS.length;index++) {\n        const face = DIRECTIONS[index];\n        blockArray.push(dimension.getBlock(VectorMath.sum(coord,face)));\n    }\n    return blockArray;\n}\n\nfunction getAdjecentBlockCoords(coord) {\n    const coordArray = [];\n    for (let index = 0;index < DIRECTIONS.length;index++) {\n        coordArray.push(VectorMath.sum(coord,DIRECTIONS[index]));\n    }\n    return coordArray;\n}\n\nexport async function blockUpdateIteration(location,dimension,callback) {\n    sendLogMessage(`starting block update iteration @ ${location.x},${location.y},${location.z} [${Mc.system.currentTick}]`);\n    let blockUpdateSignal = [];\n    blockUpdateSignal.push(...getAdjecentBlockCopies(location,dimension));\n    while (blockUpdateSignal.length !== 0) {\n        blockUpdateSignal = await waitForNextTick(() => {\n            const newBlockUpdates = [];\n            for (let index = 0;index < blockUpdateSignal.length;index++) {\n                const blockBefore = blockUpdateSignal[index];\n                const blockLocation = blockBefore.location;\n                const blockAfter = copyBlockState(dimension.getBlock(blockLocation),true);\n                if (!compareBlockStates(blockBefore,blockAfter,true)) {\n                    const adjecentBlocks = getAdjecentBlockCopies(blockLocation,dimension);\n                    for (let adjecentIndex = 0;adjecentIndex < adjecentBlocks.length;adjecentIndex++) {\n                        const adjecentBlock = adjecentBlocks[adjecentIndex];\n                        if (newBlockUpdates.find((block) => VectorMath.compare(block.location,adjecentBlock.location)) == null) {\n                            newBlockUpdates.push(adjecentBlock);\n                        }\n                    }\n                    callback(blockBefore,blockAfter,Mc.system.currentTick);\n                }\n            }\n            return newBlockUpdates;\n        });\n    }\n    logMessage(`ending block update iteration [${Mc.system.currentTick}]`);\n}\n\nasync function blockUpdateIterationObject(location,dimension,callback) {\n    let blockUpdateSignal = {};\n    const initialAdjecentBlocks = getAdjecentBlockCopies(location,dimension);\n    for (let adjecentIndex = 0;adjecentIndex < initialAdjecentBlocks.length;adjecentIndex++) {\n        const adjecentBlock = initialAdjecentBlocks[adjecentIndex];\n        const adjecentBlockId = `${adjecentBlock.location.x},${adjecentBlock.location.y},${adjecentBlock.location.z}`;\n        blockUpdateSignal[adjecentBlockId] = adjecentBlock;\n    }\n    while (!isEmptyObject(blockUpdateSignal)) {\n        blockUpdateSignal = await waitForNextTick(() => {\n            const newBlockUpdates = {};\n            for (const blockBeforeId in blockUpdateSignal) {\n                const blockBefore = blockUpdateSignal[blockBeforeId];\n                const blockLocation = blockBefore.location;\n                const blockAfter = copyBlockState(dimension.getBlock(blockLocation),true);\n                if (!compareBlockStates(blockBefore,blockAfter,true)) {\n                    const adjecentBlocks = getAdjecentBlockCopies(blockLocation,dimension);\n                    for (let adjecentIndex = 0;adjecentIndex < adjecentBlocks.length;adjecentIndex++) {\n                        const adjecentBlock = adjecentBlocks[adjecentIndex];\n                        const adjecentBlockId = `${adjecentBlock.location.x},${adjecentBlock.location.y},${adjecentBlock.location.z}`;\n                        newBlockUpdates[adjecentBlockId] = adjecentBlock;\n                    }\n                    callback(blockBefore,blockAfter,Mc.system.currentTick);\n                }\n            }\n            return newBlockUpdates;\n        });\n    }\n}\n\nasync function waitForNextTick(callback) {\n    return new Promise((resolve,reject) => {\n        Mc.system.runTimeout(() => {\n            try {\n                resolve(callback());\n            } catch (error) {\n                reject(error)\n            }\n        })\n    })\n}\n\nfunction isEmptyObject(object) {\n    for (const _ in object) return false;\n    return true;\n}\n\nexport function generateBlockArea(coord,steps = 10,callback = null) {\n    const coords = [];\n    const vectorDefinitions = {};\n    //Tertiary vectors are sent at the beginning from the starting coordinate and also from the secondary and primary vectors. Those cover the whole Y axis.\n    vectorDefinitions.tertiary = [\n            {\n                vector: {x:0,y:1,z:0}\n            },\n            {\n                vector: {x:0,y:-1,z:0}\n            }\n    ];\n    //Secondary vectors are sent by the primary vectors. Those cover each X,Z quadrant of the area.\n    vectorDefinitions.secondary = [\n            {\n                vector: {x:0,y:0,z:1},\n                sends: vectorDefinitions.tertiary\n            },\n            {\n                vector: {x:0,y:0,z:-1},\n                sends: vectorDefinitions.tertiary\n            },\n            {\n                vector: {x:-1,y:0,z:0},\n                sends: vectorDefinitions.tertiary\n            },\n            {\n                vector: {x:1,y:0,z:0},\n                sends: vectorDefinitions.tertiary\n            }\n    ];\n    //Primary vectors are sent at the beginning from the starting coordinate. Those are the edges between the X,Z quadrants of the area.\n    vectorDefinitions.primary = [\n            {\n                vector: {x:1,y:0,z:0},\n                sends: [vectorDefinitions.secondary[0],...vectorDefinitions.tertiary]\n            },\n            {\n                vector: {x:-1,y:0,z:0},\n                sends: [vectorDefinitions.secondary[1],...vectorDefinitions.tertiary]\n            },\n            {\n                vector: {x:0,y:0,z:1},\n                sends: [vectorDefinitions.secondary[2],...vectorDefinitions.tertiary]\n            },\n            {\n                vector: {x:0,y:0,z:-1},\n                sends: [vectorDefinitions.secondary[3],...vectorDefinitions.tertiary]\n            }\n  \n    ];\n    let sentVectors = [];\n    for (let step = 0;step <= steps;step++) {\n        const lastLength = sentVectors.length;\n        if (step === 0) {\n            const location = VectorMath.copy(coord);\n            for (let index = 0;index < vectorDefinitions.primary.length;index++) {\n                sentVectors.push({\n                    location: VectorMath.copy(location),\n                    definition: vectorDefinitions.primary[index]\n                });\n            }\n            for (let index = 0;index < vectorDefinitions.tertiary.length;index++) {\n                sentVectors.push({\n                    location: VectorMath.copy(location),\n                    definition: vectorDefinitions.tertiary[index]\n                });\n            }\n            callback(location);\n        }\n        for (let index = 0;index < lastLength;index++) {\n            const vector = sentVectors[index];\n            const location = VectorMath.sum(vector.location,vector.definition.vector);\n            vector.location = VectorMath.copy(location);\n            callback(location);\n            if (vector.definition.sends) {\n                for (let sendIndex = 0;sendIndex < vector.definition.sends.length;sendIndex++) {\n                    sentVectors.push({\n                        location: VectorMath.copy(location),\n                        definition: vector.definition.sends[sendIndex]\n                    });\n                }\n            }\n        }\n    }\n    return coords;\n}"]}